// BookLibrary.ViewModels/AuthorManagement/AuthorManagerViewModel.cs
// Make sure these using statements are present at the top of your file.
using BookLibrary.ApplicationServices.Contracts;
using BookLibrary.Domain.Entities;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System;
using System.ComponentModel;
using ApplicationServices.Contracts;
using ViewModels; // Required for PropertyChangedEventArgs

namespace BookLibrary.ViewModels.AuthorManagement
{
    public partial class AuthorManagerViewModel : ViewModelBase
    {
        private readonly IAuthorService _authorService;

        [ObservableProperty]
        private ObservableCollection<Author> authors;

        [ObservableProperty]
        private Author selectedAuthor;

        [ObservableProperty]
        private string newAuthorFirstName;

        [ObservableProperty]
        private string newAuthorLastName;

        [ObservableProperty]
        private string newAuthorBiography;

        [ObservableProperty]
        private bool isLoading;

        [ObservableProperty]
        private bool canSaveAuthor;

        // --- Commands (Generated by [RelayCommand] attributes below) ---
        // DO NOT manually declare these public properties here.
        // The source generator handles their creation and initialization.

        private string currentSortProperty = nameof(Author.AuthorId);
        private bool isAscending = true;


        public AuthorManagerViewModel(IAuthorService authorService)
        {
            _authorService = authorService;
            authors = new ObservableCollection<Author>();
            canSaveAuthor = false; // Initialize to false by default

            // Subscribe to property changes of the ViewModel itself.
            PropertyChanged += (sender, e) =>
            {
                // When the 'SelectedAuthor' property (the reference) changes:
                if (e.PropertyName == nameof(SelectedAuthor))
                {
                    // Always re-evaluate CanExecute for commands dependent on SelectedAuthor when its reference changes.
                    SaveAuthorCommand.NotifyCanExecuteChanged();
                    DeleteAuthorCommand.NotifyCanExecuteChanged();
                }
                // When NewAuthorFirstName, NewAuthorLastName, or NewAuthorBiography changes, re-evaluate Add command.
                else if (e.PropertyName == nameof(NewAuthorFirstName) || 
                         e.PropertyName == nameof(NewAuthorLastName) || 
                         e.PropertyName == nameof(NewAuthorBiography))
                {
                    AddAuthorCommand.NotifyCanExecuteChanged();
                }
                // When CanSaveAuthor changes, no need to do anything as the UI will update via binding
            };
            
            // Initial data load
            _ = LoadAuthorsAsync();
        }

        // --- CommunityToolkit.Mvvm Generated Partial Methods ---
        // This method is automatically called by the [ObservableProperty] source generator
        // whenever the 'SelectedAuthor' property's value changes.
        partial void OnSelectedAuthorChanged(Author oldValue, Author newValue)
        {
            // Unsubscribe from the PropertyChanged event of the previously selected author
            if (oldValue != null)
            {
                oldValue.PropertyChanged -= SelectedAuthor_PropertyChanged;
            }

            // Subscribe to the PropertyChanged event of the newly selected author
            if (newValue != null)
            {
                newValue.PropertyChanged += SelectedAuthor_PropertyChanged;
                // Update CanSaveAuthor based on the new selected author
                UpdateCanSaveAuthor();
            }
            else
            {
                CanSaveAuthor = false; // Reset CanSaveAuthor if no author is selected
            }
            
            // The NotifyCanExecuteChanged for Save/Delete commands is handled in the main PropertyChanged subscription (for reference changes)
            // and in SelectedAuthor_PropertyChanged (for internal changes).
        }
        
        /// <summary>
        /// Handles property changes within the currently SelectedAuthor object.
        /// This method is subscribed to the Author.PropertyChanged event.
        /// </summary>
        private void SelectedAuthor_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            // Always update CanSaveAuthor when any property of the author changes
            // This ensures we capture all relevant changes
            UpdateCanSaveAuthor();
            
            // This is the public command generated by [RelayCommand]
            SaveAuthorCommand?.NotifyCanExecuteChanged();
            
            // Debugging info to verify property changes are being detected
            System.Diagnostics.Debug.WriteLine($"Author property changed: {e.PropertyName}");
        }

        // --- Predicates for Command Execution ---

        private bool CanAddAuthor()
        {
            return !string.IsNullOrWhiteSpace(NewAuthorFirstName) && !string.IsNullOrWhiteSpace(NewAuthorLastName);
        }

        private bool CanSaveAuthorFunc()
        {
            // Updated to check that all required fields are filled in
            return SelectedAuthor != null && 
                   !string.IsNullOrWhiteSpace(SelectedAuthor.FirstName) && 
                   !string.IsNullOrWhiteSpace(SelectedAuthor.LastName) && 
                   !string.IsNullOrWhiteSpace(SelectedAuthor.Biography);
        }

        private bool CanDeleteAuthor()
        {
            return SelectedAuthor != null;
        }

        // --- Asynchronous Methods (Command Implementations) ---

        [RelayCommand] // Generates public AsyncRelayCommand LoadAuthorsCommand { get; }
        private async Task LoadAuthorsAsync()
        {
            IsLoading = true;
            try
            {
                var loadedAuthors = await _authorService.GetAllAuthorsAsync();
                Authors.Clear();
                foreach (var author in loadedAuthors)
                {
                    Authors.Add(author);
                }
                SortAuthors(currentSortProperty, false);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error loading authors: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
                // These commands are public properties generated by [RelayCommand]
                SaveAuthorCommand.NotifyCanExecuteChanged();
                DeleteAuthorCommand.NotifyCanExecuteChanged();
            }
        }

        [RelayCommand(CanExecute = nameof(CanAddAuthor))] // Generates public AsyncRelayCommand AddAuthorCommand { get; }
        private async Task AddAuthorAsync()
        {
            if (!CanAddAuthor()) return;

            IsLoading = true;
            try
            {
                var newAuthor = new Author
                {
                    FirstName = NewAuthorFirstName,
                    LastName = NewAuthorLastName,
                    Biography = NewAuthorBiography
                };

                await _authorService.AddAuthorAsync(newAuthor);
                await LoadAuthorsAsync();
                NewAuthorFirstName = string.Empty;
                NewAuthorLastName = string.Empty;
                NewAuthorBiography = string.Empty;
                MessageBox.Show("Author added successfully!", "Success", MessageBoxButton.OK, MessageBoxImage.Information);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error adding author: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand] // Use standard declaration without CanExecute parameter
        private async Task SaveAuthorAsync()
        {
            if (!CanSaveAuthorFunc()) return;

            IsLoading = true;
            try
            {
                await _authorService.UpdateAuthorAsync(SelectedAuthor);
                await LoadAuthorsAsync();
                MessageBox.Show("Author updated successfully!", "Success", MessageBoxButton.OK, MessageBoxImage.Information);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error saving author: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand(CanExecute = nameof(CanDeleteAuthor))] // Generates public AsyncRelayCommand DeleteAuthorCommand { get; }
        private async Task DeleteAuthorAsync()
        {
            if (!CanDeleteAuthor()) return;

            if (MessageBox.Show($"Are you sure you want to delete '{SelectedAuthor.FirstName} {SelectedAuthor.LastName}'?",
                                "Confirm Deletion", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes)
            {
                IsLoading = true;
                try
                {
                    await _authorService.DeleteAuthorAsync(SelectedAuthor.AuthorId);
                    await LoadAuthorsAsync();
                    SelectedAuthor = null;
                    MessageBox.Show("Author deleted successfully!", "Success", MessageBoxButton.OK, MessageBoxImage.Information);
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Error deleting author: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                }
                finally
                {
                    IsLoading = false;
                }
            }
        }

        // --- Sorting Logic ---
        [RelayCommand] // Generates public RelayCommand SortByIdCommand { get; }
        private void SortById() => SortAuthors(nameof(Author.AuthorId));

        [RelayCommand] // Generates public RelayCommand SortByNameCommand { get; }
        private void SortByName() => SortAuthors(nameof(Author.LastName));

        private void SortAuthors(string propertyName, bool toggleDirection = true)
        {
            if (currentSortProperty == propertyName && toggleDirection)
            {
                isAscending = !isAscending;
            }
            else
            {
                currentSortProperty = propertyName;
                isAscending = true;
            }

            IOrderedEnumerable<Author> sortedAuthors;

            switch (currentSortProperty)
            {
                case nameof(Author.AuthorId):
                    sortedAuthors = isAscending ? Authors.OrderBy(a => a.AuthorId) : Authors.OrderByDescending(a => a.AuthorId);
                    break;
                case nameof(Author.LastName):
                case nameof(Author.FirstName):
                    sortedAuthors = isAscending ? Authors.OrderBy(a => a.LastName, StringComparer.OrdinalIgnoreCase)
                                                          .ThenBy(a => a.FirstName, StringComparer.OrdinalIgnoreCase)
                                                : Authors.OrderByDescending(a => a.LastName, StringComparer.OrdinalIgnoreCase)
                                                          .ThenByDescending(a => a.FirstName, StringComparer.OrdinalIgnoreCase);
                    break;
                default:
                    return;
            }

            Authors.Clear();
            foreach (var author in sortedAuthors)
            {
                Authors.Add(author);
            }
        }

        private void UpdateCanSaveAuthor()
        {
            if (SelectedAuthor == null)
            {
                CanSaveAuthor = false;
                return;
            }

            // Updated to require all fields to be filled in
            bool allFieldsFilled = !string.IsNullOrWhiteSpace(SelectedAuthor.FirstName) &&
                                   !string.IsNullOrWhiteSpace(SelectedAuthor.LastName) &&
                                   !string.IsNullOrWhiteSpace(SelectedAuthor.Biography);
            
            // Update the property directly without checking previous value
            // This ensures the binding is always notified
            CanSaveAuthor = allFieldsFilled;

            // Debugging message to trace the CanSaveAuthor updates
            System.Diagnostics.Debug.WriteLine($"UpdateCanSaveAuthor: SelectedAuthor='{SelectedAuthor.FirstName} {SelectedAuthor.LastName}', CanSaveAuthor={CanSaveAuthor}");
            
            // This is required because the command's CanExecute needs to be re-evaluated
            SaveAuthorCommand?.NotifyCanExecuteChanged();
        }
    }
}
