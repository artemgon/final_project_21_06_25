// BookLibrary.ViewModels/AuthorManagement/AuthorManagerViewModel.cs
// Make sure these using statements are present at the top of your file.
using BookLibrary.ApplicationServices.Contracts;
using BookLibrary.Domain.Entities;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System;
using System.ComponentModel;
using ApplicationServices.Contracts;
using ViewModels; // Required for PropertyChangedEventArgs

namespace BookLibrary.ViewModels.AuthorManagement
{
    public partial class AuthorManagerViewModel : ViewModelBase
    {
        private readonly IAuthorService _authorService;

        [ObservableProperty]
        private ObservableCollection<Author> authors;

        [ObservableProperty]
        private Author selectedAuthor;

        [ObservableProperty]
        private string newAuthorFirstName;

        [ObservableProperty]
        private string newAuthorLastName;

        [ObservableProperty]
        private string newAuthorBiography;

        [ObservableProperty]
        private bool isLoading;

        [ObservableProperty]
        private bool canSaveAuthor;

        // --- Commands (Generated by [RelayCommand] attributes below) ---
        // DO NOT manually declare these public properties here.
        // The source generator handles their creation and initialization.
        
        // Manual command implementation for AddAuthor to ensure it works
        private AsyncRelayCommand _addAuthorCommand;
        public AsyncRelayCommand AddAuthorCommand
        {
            get
            {
                if (_addAuthorCommand == null)
                {
                    _addAuthorCommand = new AsyncRelayCommand(AddAuthorAsync, CanAddAuthor);
                    System.Diagnostics.Debug.WriteLine("AddAuthorCommand created manually");
                }
                return _addAuthorCommand;
            }
        }

        // Manual command implementation for DeleteAuthor to ensure it works
        private AsyncRelayCommand _deleteAuthorCommand;
        public AsyncRelayCommand DeleteAuthorCommand
        {
            get
            {
                if (_deleteAuthorCommand == null)
                {
                    _deleteAuthorCommand = new AsyncRelayCommand(DeleteAuthorAsync, CanDeleteAuthor);
                    System.Diagnostics.Debug.WriteLine("DeleteAuthorCommand created manually");
                }
                return _deleteAuthorCommand;
            }
        }

        // Add partial methods to handle property changes for new author fields
        partial void OnNewAuthorFirstNameChanged(string value)
        {
            System.Diagnostics.Debug.WriteLine($"NewAuthorFirstName changed to: '{value}'");
            AddAuthorCommand?.NotifyCanExecuteChanged();
        }

        partial void OnNewAuthorLastNameChanged(string value)
        {
            System.Diagnostics.Debug.WriteLine($"NewAuthorLastName changed to: '{value}'");
            AddAuthorCommand?.NotifyCanExecuteChanged();
        }

        partial void OnNewAuthorBiographyChanged(string value)
        {
            System.Diagnostics.Debug.WriteLine($"NewAuthorBiography changed to: '{value}'");
            AddAuthorCommand?.NotifyCanExecuteChanged();
        }

        // Add partial method to handle SelectedAuthor changes and update DeleteAuthorCommand
        partial void OnSelectedAuthorChanged(Author value)
        {
            System.Diagnostics.Debug.WriteLine($"SelectedAuthor changed to: {value?.FirstName} {value?.LastName}");
            DeleteAuthorCommand?.NotifyCanExecuteChanged();
            System.Diagnostics.Debug.WriteLine($"DeleteAuthorCommand.CanExecute after change: {DeleteAuthorCommand?.CanExecute(null)}");
        }

        private string currentSortProperty = nameof(Author.AuthorId);
        private bool isAscending = true;


        public AuthorManagerViewModel(IAuthorService authorService)
        {
            _authorService = authorService;
            authors = new ObservableCollection<Author>();
            canSaveAuthor = false; // Initialize to false by default
            
            // Initialize the new author properties to empty strings to ensure they're not null
            newAuthorFirstName = string.Empty;
            newAuthorLastName = string.Empty;
            newAuthorBiography = string.Empty;

            // Subscribe to property changes of the ViewModel itself.
            PropertyChanged += (sender, e) =>
            {
                System.Diagnostics.Debug.WriteLine($"PropertyChanged event fired for: {e.PropertyName}");
                
                // When the 'SelectedAuthor' property (the reference) changes:
                if (e.PropertyName == nameof(SelectedAuthor))
                {
                    // Always re-evaluate CanExecute for commands dependent on SelectedAuthor when its reference changes.
                    SaveAuthorCommand.NotifyCanExecuteChanged();
                    DeleteAuthorCommand.NotifyCanExecuteChanged();
                }
                // When NewAuthorFirstName, NewAuthorLastName, or NewAuthorBiography changes, re-evaluate Add command.
                else if (e.PropertyName == nameof(NewAuthorFirstName) || 
                         e.PropertyName == nameof(NewAuthorLastName) || 
                         e.PropertyName == nameof(NewAuthorBiography))
                {
                    System.Diagnostics.Debug.WriteLine($"Notifying AddAuthorCommand.CanExecute changed. Current values - FirstName: '{NewAuthorFirstName}', LastName: '{NewAuthorLastName}'");
                    System.Diagnostics.Debug.WriteLine($"CanAddAuthor() returns: {CanAddAuthor()}");
                    AddAuthorCommand.NotifyCanExecuteChanged();
                }
                // When CanSaveAuthor changes, no need to do anything as the UI will update via binding
            };
            
            // Force initial data load when ViewModel is created
            System.Diagnostics.Debug.WriteLine("AuthorManagerViewModel constructor: Starting initial load");
            _ = InitializeAsync();
        }

        // Separate initialization method to handle async loading properly
        private async Task InitializeAsync()
        {
            try
            {
                System.Diagnostics.Debug.WriteLine("InitializeAsync: Loading authors...");
                await LoadAuthorsAsync();
                System.Diagnostics.Debug.WriteLine($"InitializeAsync: Loaded {Authors.Count} authors");
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"InitializeAsync error: {ex.Message}");
                MessageBox.Show($"Error loading initial data: {ex.Message}", "Initialization Error", MessageBoxButton.OK, MessageBoxImage.Warning);
            }
        }

        // --- CommunityToolkit.Mvvm Generated Partial Methods ---
        // This method is automatically called by the [ObservableProperty] source generator
        // whenever the 'SelectedAuthor' property's value changes.
        partial void OnSelectedAuthorChanged(Author oldValue, Author newValue)
        {
            System.Diagnostics.Debug.WriteLine($"SelectedAuthor changed from {oldValue?.FirstName} {oldValue?.LastName} to {newValue?.FirstName} {newValue?.LastName}");
            
            // Unsubscribe from the PropertyChanged event of the previously selected author
            if (oldValue != null)
            {
                oldValue.PropertyChanged -= SelectedAuthor_PropertyChanged;
            }

            // Subscribe to the PropertyChanged event of the newly selected author
            if (newValue != null)
            {
                newValue.PropertyChanged += SelectedAuthor_PropertyChanged;
                // Update CanSaveAuthor based on the new selected author
                UpdateCanSaveAuthor();
            }
            else
            {
                CanSaveAuthor = false; // Reset CanSaveAuthor if no author is selected
            }
            
            // Force DeleteAuthorCommand to re-evaluate its CanExecute state
            DeleteAuthorCommand?.NotifyCanExecuteChanged();
            System.Diagnostics.Debug.WriteLine($"DeleteAuthorCommand.CanExecute after SelectedAuthor change: {DeleteAuthorCommand?.CanExecute(null)}");
        }
        
        /// <summary>
        /// Handles property changes within the currently SelectedAuthor object.
        /// This method is subscribed to the Author.PropertyChanged event.
        /// </summary>
        private void SelectedAuthor_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            // Always update CanSaveAuthor when any property of the author changes
            // This ensures we capture all relevant changes
            UpdateCanSaveAuthor();
            
            // This is the public command generated by [RelayCommand]
            SaveAuthorCommand?.NotifyCanExecuteChanged();
            
            // Debugging info to verify property changes are being detected
            System.Diagnostics.Debug.WriteLine($"Author property changed: {e.PropertyName}");
        }

        // --- Predicates for Command Execution ---

        private bool CanAddAuthor()
        {
            bool firstNameValid = !string.IsNullOrWhiteSpace(NewAuthorFirstName);
            bool lastNameValid = !string.IsNullOrWhiteSpace(NewAuthorLastName);
            bool canAdd = firstNameValid && lastNameValid;
            
            System.Diagnostics.Debug.WriteLine($"CanAddAuthor() - FirstName: '{NewAuthorFirstName}' (Valid: {firstNameValid}), LastName: '{NewAuthorLastName}' (Valid: {lastNameValid}), Result: {canAdd}");
            
            return canAdd;
        }

        private bool CanSaveAuthorFunc()
        {
            // Updated to check that all required fields are filled in
            return SelectedAuthor != null && 
                   !string.IsNullOrWhiteSpace(SelectedAuthor.FirstName) && 
                   !string.IsNullOrWhiteSpace(SelectedAuthor.LastName) && 
                   !string.IsNullOrWhiteSpace(SelectedAuthor.Biography);
        }

        private bool CanDeleteAuthor()
        {
            bool canDelete = SelectedAuthor != null;
            System.Diagnostics.Debug.WriteLine($"CanDeleteAuthor() - SelectedAuthor: {SelectedAuthor?.FirstName} {SelectedAuthor?.LastName}, Result: {canDelete}");
            return canDelete;
        }

        // --- Asynchronous Methods (Command Implementations) ---

        [RelayCommand] // Generates public AsyncRelayCommand LoadAuthorsCommand { get; }
        private async Task LoadAuthorsAsync()
        {
            try
            {
                System.Diagnostics.Debug.WriteLine("LoadAuthorsAsync: Starting to load authors from database...");
                
                // Set loading state on UI thread
                await Application.Current.Dispatcher.InvokeAsync(() =>
                {
                    IsLoading = true;
                });
                
                // Execute database query (this works since TestDatabaseConnectionAsync works)
                var loadedAuthors = await _authorService.GetAllAuthorsAsync();
                
                System.Diagnostics.Debug.WriteLine($"LoadAuthorsAsync: Retrieved {loadedAuthors?.Count() ?? 0} authors from service");
                
                // Update UI on the UI thread
                await Application.Current.Dispatcher.InvokeAsync(() =>
                {
                    Authors.Clear();
                    
                    if (loadedAuthors != null)
                    {
                        foreach (var author in loadedAuthors)
                        {
                            Authors.Add(author);
                            System.Diagnostics.Debug.WriteLine($"Added author to UI: {author.FirstName} {author.LastName} (ID: {author.AuthorId})");
                        }
                    }
                    
                    System.Diagnostics.Debug.WriteLine($"LoadAuthorsAsync: UI updated. Final count in collection: {Authors.Count}");
                    
                    // Force UI binding refresh
                    OnPropertyChanged(nameof(Authors));
                });
                
                // Sort authors on UI thread as well
                await Application.Current.Dispatcher.InvokeAsync(() =>
                {
                    if (Authors.Count > 0)
                    {
                        SortAuthors(currentSortProperty, false);
                        System.Diagnostics.Debug.WriteLine($"LoadAuthorsAsync: After sorting, count: {Authors.Count}");
                    }
                });
                
                System.Diagnostics.Debug.WriteLine($"LoadAuthorsAsync: Completed successfully. Total authors in UI: {Authors.Count}");
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"LoadAuthorsAsync error: {ex.Message}");
                System.Diagnostics.Debug.WriteLine($"LoadAuthorsAsync stack trace: {ex.StackTrace}");
                
                await Application.Current.Dispatcher.InvokeAsync(() =>
                {
                    MessageBox.Show($"Error loading authors: {ex.Message}", "Database Error", MessageBoxButton.OK, MessageBoxImage.Error);
                });
            }
            finally
            {
                await Application.Current.Dispatcher.InvokeAsync(() =>
                {
                    IsLoading = false;
                    SaveAuthorCommand?.NotifyCanExecuteChanged();
                    DeleteAuthorCommand?.NotifyCanExecuteChanged();
                });
            }
        }

        // Remove the [RelayCommand] attribute since we're manually implementing AddAuthorCommand
        private async Task AddAuthorAsync()
        {
            if (!CanAddAuthor()) return;

            IsLoading = true;
            try
            {
                var newAuthor = new Author
                {
                    FirstName = NewAuthorFirstName,
                    LastName = NewAuthorLastName,
                    Biography = NewAuthorBiography
                };

                System.Diagnostics.Debug.WriteLine($"Adding author: {newAuthor.FirstName} {newAuthor.LastName}");
                await _authorService.AddAuthorAsync(newAuthor);
                System.Diagnostics.Debug.WriteLine("Author added to database successfully");
                
                // Clear the form fields first
                NewAuthorFirstName = string.Empty;
                NewAuthorLastName = string.Empty;
                NewAuthorBiography = string.Empty;
                System.Diagnostics.Debug.WriteLine("Form fields cleared");
                
                // Get the current count before refresh
                int countBefore = Authors.Count;
                System.Diagnostics.Debug.WriteLine($"Authors count before refresh: {countBefore}");
                
                // Reload the authors list to include the new author
                await LoadAuthorsAsync();
                System.Diagnostics.Debug.WriteLine($"LoadAuthorsAsync completed. New count: {Authors.Count}");
                
                // Force multiple UI update notifications
                OnPropertyChanged(nameof(Authors));
                OnPropertyChanged(nameof(Authors.Count));
                
                // Use Dispatcher to ensure UI update happens on UI thread
                Application.Current.Dispatcher.Invoke(() =>
                {
                    // Select the newly added author if possible
                    if (Authors.Any())
                    {
                        var addedAuthor = Authors.OrderByDescending(a => a.AuthorId).FirstOrDefault();
                        if (addedAuthor != null)
                        {
                            SelectedAuthor = addedAuthor;
                            System.Diagnostics.Debug.WriteLine($"Selected new author: {addedAuthor.FirstName} {addedAuthor.LastName} (ID: {addedAuthor.AuthorId})");
                        }
                    }
                });
                
                MessageBox.Show($"Author added successfully! Total authors: {Authors.Count}", "Success", MessageBoxButton.OK, MessageBoxImage.Information);
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"Error adding author: {ex.Message}");
                MessageBox.Show($"Error adding author: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand] // Use standard declaration without CanExecute parameter
        private async Task SaveAuthorAsync()
        {
            if (!CanSaveAuthorFunc()) return;

            IsLoading = true;
            try
            {
                await _authorService.UpdateAuthorAsync(SelectedAuthor);
                await LoadAuthorsAsync();
                MessageBox.Show("Author updated successfully!", "Success", MessageBoxButton.OK, MessageBoxImage.Information);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error saving author: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        // Remove the [RelayCommand] attribute since we're manually implementing DeleteAuthorCommand
        private async Task DeleteAuthorAsync()
        {
            if (!CanDeleteAuthor()) return;

            if (MessageBox.Show($"Are you sure you want to delete '{SelectedAuthor.FirstName} {SelectedAuthor.LastName}'?",
                                "Confirm Deletion", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes)
            {
                IsLoading = true;
                try
                {
                    await _authorService.DeleteAuthorAsync(SelectedAuthor.AuthorId);
                    await LoadAuthorsAsync();
                    SelectedAuthor = null;
                    MessageBox.Show("Author deleted successfully!", "Success", MessageBoxButton.OK, MessageBoxImage.Information);
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Error deleting author: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                }
                finally
                {
                    IsLoading = false;
                }
            }
        }

        // --- Sorting Logic ---
        [RelayCommand] // Generates public RelayCommand SortByIdCommand { get; }
        private void SortById() => SortAuthors(nameof(Author.AuthorId));

        [RelayCommand] // Generates public RelayCommand SortByNameCommand { get; }
        private void SortByName() => SortAuthors(nameof(Author.LastName));

        private void SortAuthors(string propertyName, bool toggleDirection = true)
        {
            // Don't sort if there are no authors
            if (Authors == null || Authors.Count == 0)
            {
                System.Diagnostics.Debug.WriteLine("SortAuthors: No authors to sort, skipping.");
                return;
            }

            if (currentSortProperty == propertyName && toggleDirection)
            {
                isAscending = !isAscending;
            }
            else
            {
                currentSortProperty = propertyName;
                isAscending = true;
            }

            System.Diagnostics.Debug.WriteLine($"SortAuthors: Sorting {Authors.Count} authors by {propertyName}, ascending: {isAscending}");

            IOrderedEnumerable<Author> sortedAuthors;

            switch (currentSortProperty)
            {
                case nameof(Author.AuthorId):
                    sortedAuthors = isAscending ? Authors.OrderBy(a => a.AuthorId) : Authors.OrderByDescending(a => a.AuthorId);
                    break;
                case nameof(Author.LastName):
                case nameof(Author.FirstName):
                    sortedAuthors = isAscending ? Authors.OrderBy(a => a.LastName, StringComparer.OrdinalIgnoreCase)
                                                          .ThenBy(a => a.FirstName, StringComparer.OrdinalIgnoreCase)
                                                : Authors.OrderByDescending(a => a.LastName, StringComparer.OrdinalIgnoreCase)
                                                          .ThenByDescending(a => a.FirstName, StringComparer.OrdinalIgnoreCase);
                    break;
                default:
                    System.Diagnostics.Debug.WriteLine($"SortAuthors: Unknown property {propertyName}, keeping original order");
                    return;
            }

            // Store the sorted list before clearing
            var sortedList = sortedAuthors.ToList();
            System.Diagnostics.Debug.WriteLine($"SortAuthors: Created sorted list with {sortedList.Count} authors");

            // Clear and repopulate
            Authors.Clear();
            foreach (var author in sortedList)
            {
                Authors.Add(author);
            }
            
            System.Diagnostics.Debug.WriteLine($"SortAuthors: Completed. Final Authors count: {Authors.Count}");
        }

        private void UpdateCanSaveAuthor()
        {
            if (SelectedAuthor == null)
            {
                CanSaveAuthor = false;
                return;
            }

            // Check all three fields are filled (trim whitespace and check for null/empty)
            bool firstNameFilled = !string.IsNullOrWhiteSpace(SelectedAuthor.FirstName);
            bool lastNameFilled = !string.IsNullOrWhiteSpace(SelectedAuthor.LastName);
            bool biographyFilled = !string.IsNullOrWhiteSpace(SelectedAuthor.Biography);
            
            bool allFieldsFilled = firstNameFilled && lastNameFilled && biographyFilled;
            
            // Debugging info to see what's happening
            System.Diagnostics.Debug.WriteLine($"UpdateCanSaveAuthor Debug:");
            System.Diagnostics.Debug.WriteLine($"  FirstName: '{SelectedAuthor.FirstName}' - Filled: {firstNameFilled}");
            System.Diagnostics.Debug.WriteLine($"  LastName: '{SelectedAuthor.LastName}' - Filled: {lastNameFilled}");
            System.Diagnostics.Debug.WriteLine($"  Biography: '{SelectedAuthor.Biography}' - Filled: {biographyFilled}");
            System.Diagnostics.Debug.WriteLine($"  All Fields Filled: {allFieldsFilled}");
            System.Diagnostics.Debug.WriteLine($"  Setting CanSaveAuthor to: {allFieldsFilled}");
            
            // Force property change notification by setting to opposite first if needed
            if (CanSaveAuthor == allFieldsFilled)
            {
                CanSaveAuthor = !allFieldsFilled;
            }
            CanSaveAuthor = allFieldsFilled;
            
            // This is required because the command's CanExecute needs to be re-evaluated
            SaveAuthorCommand?.NotifyCanExecuteChanged();
        }

        // --- Track CanSaveAuthor Changes ---
        partial void OnCanSaveAuthorChanged(bool value)
        {
            // This method is called whenever CanSaveAuthor changes
            System.Diagnostics.Debug.WriteLine($"CanSaveAuthor property changed to: {value}");
            
            // Force UI update by raising PropertyChanged manually
            OnPropertyChanged(nameof(CanSaveAuthor));
        }

        // Public method to manually trigger the update for testing
        public void ManuallyUpdateCanSave()
        {
            UpdateCanSaveAuthor();
        }

        // Add a direct database test method
        public async Task<string> TestDatabaseConnectionAsync()
        {
            try
            {
                System.Diagnostics.Debug.WriteLine("TestDatabaseConnectionAsync: Starting direct database test...");
                var authors = await _authorService.GetAllAuthorsAsync();
                var count = authors?.Count() ?? 0;
                
                var result = $"✅ Database Connection Success!\n" +
                           $"Authors found: {count}\n";
                
                if (count > 0)
                {
                    result += "Sample authors:\n";
                    foreach (var author in authors.Take(3))
                    {
                        result += $"- {author.FirstName} {author.LastName}\n";
                    }
                }
                
                System.Diagnostics.Debug.WriteLine($"TestDatabaseConnectionAsync: Success with {count} authors");
                return result;
            }
            catch (Exception ex)
            {
                System.Diagnostics.Debug.WriteLine($"TestDatabaseConnectionAsync: ERROR - {ex.Message}");
                return $"❌ Database Connection Failed!\n\nError: {ex.Message}\n\nCheck Debug Output for details.";
            }
        }
    }
}
