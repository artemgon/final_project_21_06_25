// BookLibrary.ViewModels/AuthorManagement/AuthorManagerViewModel.cs
// Make sure these using statements are present at the top of your file.
using BookLibrary.ApplicationServices.Contracts;
using Domain.Entities;
using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System;
using System.ComponentModel;
using ApplicationServices.Contracts;
using BookLibrary.Domain.Entities;
using ViewModels; // Required for PropertyChangedEventArgs

namespace BookLibrary.ViewModels.AuthorManagement
{
    public partial class AuthorManagerViewModel : ViewModelBase
    {
        private readonly IAuthorService _authorService;

        [ObservableProperty]
        private ObservableCollection<Author> authors;

        [ObservableProperty]
        private Author selectedAuthor;

        [ObservableProperty]
        private string newAuthorFirstName;

        [ObservableProperty]
        private string newAuthorLastName;

        [ObservableProperty]
        private string newAuthorBiography;

        [ObservableProperty]
        private bool isLoading;

        // --- Commands (Generated by [RelayCommand] attributes below) ---
        // DO NOT manually declare these public properties here.
        // The source generator handles their creation and initialization.

        private string currentSortProperty = nameof(Author.AuthorId);
        private bool isAscending = true;


        public AuthorManagerViewModel(IAuthorService authorService)
        {
            _authorService = authorService;
            authors = new ObservableCollection<Author>();

            // Subscribe to property changes of the ViewModel itself.
            PropertyChanged += (sender, e) =>
            {
                // When the 'SelectedAuthor' property (the reference) changes:
                // The subscription/unsubscription of the *inner* Author's PropertyChanged
                // event is now handled by the OnSelectedAuthorChanged partial method.
                // This block just needs to trigger command re-evaluation when the *reference* changes.
                if (e.PropertyName == nameof(SelectedAuthor))
                {
                    // Always re-evaluate CanExecute for commands dependent on SelectedAuthor when its reference changes.
                    // These are the public commands generated by [RelayCommand]
                    SaveAuthorCommand.NotifyCanExecuteChanged();
                    DeleteAuthorCommand.NotifyCanExecuteChanged();
                }
                // When NewAuthorFirstName or NewAuthorLastName changes, re-evaluate Add command.
                if (e.PropertyName == nameof(NewAuthorFirstName) || e.PropertyName == nameof(NewAuthorLastName))
                {
                    // This is the public command generated by [RelayCommand]
                    AddAuthorCommand.NotifyCanExecuteChanged();
                }
            };
            
            // Initial data load (fire and forget)
            _ = LoadAuthorsAsync();
        }

        // --- CommunityToolkit.Mvvm Generated Partial Methods ---
        // This method is automatically called by the [ObservableProperty] source generator
        // whenever the 'SelectedAuthor' property's value changes.
        partial void OnSelectedAuthorChanged(Author oldValue, Author newValue)
        {
            // Unsubscribe from the PropertyChanged event of the previously selected author
            if (oldValue != null)
            {
                oldValue.PropertyChanged -= SelectedAuthor_PropertyChanged;
            }

            // Subscribe to the PropertyChanged event of the newly selected author
            if (newValue != null)
            {
                newValue.PropertyChanged += SelectedAuthor_PropertyChanged;
            }
            // The NotifyCanExecuteChanged for Save/Delete commands is already handled in the main PropertyChanged subscription.
            // This method is primarily for managing the subscription to the author entity's internal changes.
        }
        
        /// <summary>
        /// Handles property changes within the currently SelectedAuthor object.
        /// This method is subscribed to the Author.PropertyChanged event.
        /// </summary>
        private void SelectedAuthor_PropertyChanged(object sender, PropertyChangedEventArgs e)
        {
            // Re-evaluate Save command's CanExecute state when relevant properties of the selected author are modified.
            if (e.PropertyName == nameof(Author.FirstName) || 
                e.PropertyName == nameof(Author.LastName) || 
                e.PropertyName == nameof(Author.Biography))
            {
                // This is the public command generated by [RelayCommand]
                SaveAuthorCommand.NotifyCanExecuteChanged();
            }
        }

        // --- Predicates for Command Execution ---

        private bool CanAddAuthor()
        {
            return !string.IsNullOrWhiteSpace(NewAuthorFirstName) && !string.IsNullOrWhiteSpace(NewAuthorLastName);
        }

        private bool CanSaveAuthor()
        {
            return SelectedAuthor != null &&
                   !string.IsNullOrWhiteSpace(SelectedAuthor.FirstName) &&
                   !string.IsNullOrWhiteSpace(SelectedAuthor.LastName);
        }

        private bool CanDeleteAuthor()
        {
            return SelectedAuthor != null;
        }

        // --- Asynchronous Methods (Command Implementations) ---

        [RelayCommand] // Generates public AsyncRelayCommand LoadAuthorsCommand { get; }
        private async Task LoadAuthorsAsync()
        {
            IsLoading = true;
            try
            {
                var loadedAuthors = await _authorService.GetAllAuthorsAsync();
                Authors.Clear();
                foreach (var author in loadedAuthors)
                {
                    Authors.Add(author);
                }
                SortAuthors(currentSortProperty, false);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error loading authors: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
                // These commands are public properties generated by [RelayCommand]
                SaveAuthorCommand.NotifyCanExecuteChanged();
                DeleteAuthorCommand.NotifyCanExecuteChanged();
            }
        }

        [RelayCommand(CanExecute = nameof(CanAddAuthor))] // Generates public AsyncRelayCommand AddAuthorCommand { get; }
        private async Task AddAuthorAsync()
        {
            if (!CanAddAuthor()) return;

            IsLoading = true;
            try
            {
                var newAuthor = new Author
                {
                    FirstName = NewAuthorFirstName,
                    LastName = NewAuthorLastName,
                    Biography = NewAuthorBiography
                };

                await _authorService.AddAuthorAsync(newAuthor);
                await LoadAuthorsAsync();
                NewAuthorFirstName = string.Empty;
                NewAuthorLastName = string.Empty;
                NewAuthorBiography = string.Empty;
                MessageBox.Show("Author added successfully!", "Success", MessageBoxButton.OK, MessageBoxImage.Information);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error adding author: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand(CanExecute = nameof(CanSaveAuthor))] // Generates public AsyncRelayCommand SaveAuthorCommand { get; }
        private async Task SaveAuthorAsync()
        {
            if (!CanSaveAuthor()) return;

            IsLoading = true;
            try
            {
                await _authorService.UpdateAuthorAsync(SelectedAuthor);
                await LoadAuthorsAsync();
                MessageBox.Show("Author updated successfully!", "Success", MessageBoxButton.OK, MessageBoxImage.Information);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Error saving author: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                IsLoading = false;
            }
        }

        [RelayCommand(CanExecute = nameof(CanDeleteAuthor))] // Generates public AsyncRelayCommand DeleteAuthorCommand { get; }
        private async Task DeleteAuthorAsync()
        {
            if (!CanDeleteAuthor()) return;

            if (MessageBox.Show($"Are you sure you want to delete '{SelectedAuthor.FirstName} {SelectedAuthor.LastName}'?",
                                "Confirm Deletion", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes)
            {
                IsLoading = true;
                try
                {
                    await _authorService.DeleteAuthorAsync(SelectedAuthor.AuthorId);
                    await LoadAuthorsAsync();
                    SelectedAuthor = null;
                    MessageBox.Show("Author deleted successfully!", "Success", MessageBoxButton.OK, MessageBoxImage.Information);
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"Error deleting author: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                }
                finally
                {
                    IsLoading = false;
                }
            }
        }

        // --- Sorting Logic ---
        [RelayCommand] // Generates public RelayCommand SortByIdCommand { get; }
        private void SortById() => SortAuthors(nameof(Author.AuthorId));

        [RelayCommand] // Generates public RelayCommand SortByNameCommand { get; }
        private void SortByName() => SortAuthors(nameof(Author.LastName));

        private void SortAuthors(string propertyName, bool toggleDirection = true)
        {
            if (currentSortProperty == propertyName && toggleDirection)
            {
                isAscending = !isAscending;
            }
            else
            {
                currentSortProperty = propertyName;
                isAscending = true;
            }

            IOrderedEnumerable<Author> sortedAuthors;

            switch (currentSortProperty)
            {
                case nameof(Author.AuthorId):
                    sortedAuthors = isAscending ? Authors.OrderBy(a => a.AuthorId) : Authors.OrderByDescending(a => a.AuthorId);
                    break;
                case nameof(Author.LastName):
                case nameof(Author.FirstName):
                    sortedAuthors = isAscending ? Authors.OrderBy(a => a.LastName, StringComparer.OrdinalIgnoreCase)
                                                          .ThenBy(a => a.FirstName, StringComparer.OrdinalIgnoreCase)
                                                : Authors.OrderByDescending(a => a.LastName, StringComparer.OrdinalIgnoreCase)
                                                          .ThenByDescending(a => a.FirstName, StringComparer.OrdinalIgnoreCase);
                    break;
                default:
                    return;
            }

            Authors.Clear();
            foreach (var author in sortedAuthors)
            {
                Authors.Add(author);
            }
        }
    }
}
